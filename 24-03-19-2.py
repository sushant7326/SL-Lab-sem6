# -*- coding: utf-8 -*-
"""24-03-19-2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bhAbCeFk6ViP3KTtoEiBkFZ2rH4rZVu8
"""

!pip install keras_preprocessing

import tensorflow as tf
import tensorflow.keras as keras
from tensorflow.keras import layers
from tensorflow.keras import callbacks
import os
import numpy as np
import matplotlib.pyplot as plt
from keras_preprocessing.image import ImageDataGenerator
from tensorflow.keras.layers.experimental import preprocessing

from google.colab import files
uploaded = files.upload()

import zipfile
import io

uploaded_file_name = 'dataset.zip'
with zipfile.ZipFile(io.BytesIO(uploaded[uploaded_file_name]), 'r') as zip_ref:
  zip_ref.extractall('/content/')

"""Part 1: Preprocessing the Training Data"""

# First, we instantiate the ImageData Generator
# We want to have the image rescaled in the range [0,1] so we set rescale as 1./255, the 1. is ...... (kuchh to tha, sir ne scroll nhi kiya)
# and be sure that 1/255 is treated as a floating point division
# We also want that training data is split into 80% train and 20% validation sets, so we set ........ (kuchh to tha, sir ne scroll phir se nhi kiya)

training_datagen = ImageDataGenerator(
    rescale=1./255,
    horizontal_flip=True,
    rotation_range=90,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    validation_split=0.3
)

training_set = training_datagen.flow_from_directory('dataset/training_set',
                                                    target_size=(64,64),
                                                    class_mode='binary',
                                                    subset='training')

validation_set = training_datagen.flow_from_directory('dataset/training_set',
                                                    target_size=(64,64),
                                                    class_mode='binary',
                                                    subset='validation')

"""Processing the DataSet"""

test_datagen = ImageDataGenerator(rescale=1./255)

test_set = test_datagen.flow_from_directory('dataset/test_set',
                                          target_size=(64,64),
                                          class_mode='binary')

"""Part 2: Building the CNN"""

# Initialising the CNN
cnn = tf.keras.models.Sequential()

# Step 1: 1st Convolution Layer
cnn.add(tf.keras.layers.Conv2D(filters=32,
                               kernel_size=3,
                               activation='relu',
                               input_shape=[64,64,3]))

# Step 2: 1st Pooling Layer
cnn.add(tf.keras.layers.MaxPool2D(pool_size=2,
                                  strides=2))

# Step 3: 2nd Convolution Layer
cnn.add(tf.keras.layers.Conv2D(filters=32,
                               kernel_size=3,
                               activation='relu'))

# Step 4: 2nd Pooling Layer
cnn.add(tf.keras.layers.MaxPool2D(pool_size=2,
                                  strides=2))

# Step 5: 3rd Convolution Layer
cnn.add(tf.keras.layers.Conv2D(filters=64,
                               kernel_size=3,
                               activation='relu'))

# Step 6: 3rd Pooling Layer
cnn.add(tf.keras.layers.MaxPool2D(pool_size=2,
                                  strides=2))

# Step 7: Flattening
cnn.add(tf.keras.layers.Flatten())

# Step 8: Full Connection
cnn.add(tf.keras.layers.Dense(units=128,
                              activation='relu'))

# Step 9: Output Layer
cnn.add(tf.keras.layers.Dense(units=1,
                              activation='sigmoid'))

"""Part 3: Training the CNN"""

# Compiling the CNN
cnn.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

cnn.summary()

"""Fit the model and validate on validation set"""

history = cnn.fit(x = training_set, validation_data=validation_set, epochs=50)

import pandas as pd
history_df = pd.DataFrame(history.history)
history_df.loc[:, ['loss', 'val_loss']].plot(title='Cross-entropy')
history_df.loc[:, ['accuracy', 'val_accuracy']].plot(title='Accuracy')

